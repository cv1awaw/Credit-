import logging
import os
import json
import asyncio

from telegram import Bot, Update, ReplyKeyboardMarkup, ReplyKeyboardRemove
from telegram.ext import (
    ApplicationBuilder,
    CommandHandler,
    MessageHandler,
    filters,
    ContextTypes,
    ConversationHandler
)
from telegram.ext.filters import MessageFilter

# Logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# States
CHOOSING_OPTION, GET_THEORETICAL_CREDIT, GET_PRACTICAL_CREDIT, SEND_MESSAGE = range(4)
BLOK_MATERIA, BLOK_TOTAL, BLOK_TAKEN = range(5, 8)
USER_ID_WAITING_FOR_MESSAGE = 10
BROADCAST_ASK_MESSAGE, BROADCAST_CONFIRMATION = range(20, 22)

# For /user_m
USER_M_WAITING_FOR_MESSAGE = 30

# For /hey
HEY_WAITING_FOR_MESSAGE = 999

# IDs
SPECIAL_USER_ID = 77655677655
AUTHORIZED_USER_ID = 6177929931

# JSON
MUTED_USERS_FILE = 'muted_users.json'
USERS_FILE = 'users.json'
WELCOME_MSGS_FILE = 'welcome_msgs.json'  # store custom welcomes

MAIN_MENU_KEYBOARD = [
    ['Ø­Ø³Ø§Ø¨ ØºÙŠØ§Ø¨ Ø§Ù„Ù†Ø¸Ø±ÙŠ', 'Ø­Ø³Ø§Ø¨ ØºÙŠØ§Ø¨ Ø§Ù„Ø¹Ù…Ù„ÙŠ'],
    ['Ø§Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø© Ù„ØµØ§Ø­Ø¨ Ø§Ù„Ø¨ÙˆØª', 'Ø­Ø³Ø§Ø¨ Ø¯Ø±Ø¬ØªÙƒ Ø¨Ù„Ø¨Ù„ÙˆÙƒ']
]

def load_override_welcomes():
    """Load custom welcome messages { user_id: "message" }."""
    if os.path.exists(WELCOME_MSGS_FILE):
        with open(WELCOME_MSGS_FILE, 'r', encoding='utf-8') as f:
            try:
                data = json.load(f)  # { "123": "some msg" }
                return {int(k): v for k, v in data.items()}
            except json.JSONDecodeError:
                return {}
    return {}

def save_override_welcomes(mapping):
    """Save { user_id: "message" } as { "123": "some msg" } to JSON."""
    to_save = {str(k): v for k, v in mapping.items()}
    with open(WELCOME_MSGS_FILE, 'w', encoding='utf-8') as f:
        json.dump(to_save, f, ensure_ascii=False)

def load_muted_users():
    if os.path.exists(MUTED_USERS_FILE):
        with open(MUTED_USERS_FILE, 'r') as f:
            try:
                return set(json.load(f))
            except json.JSONDecodeError:
                return set()
    return set()

def save_muted_users(muted):
    with open(MUTED_USERS_FILE, 'w') as f:
        json.dump(list(muted), f)

def load_users():
    if os.path.exists(USERS_FILE):
        with open(USERS_FILE, 'r') as f:
            try:
                return set(json.load(f))
            except json.JSONDecodeError:
                return set()
    return set()

def save_users(userset):
    with open(USERS_FILE, 'w') as f:
        json.dump(list(userset), f)

# Global sets/dicts
muted_users = load_muted_users()
known_users = load_users()
override_welcome_messages = load_override_welcomes()

async def show_main_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "Ø§Ø®ØªØ± Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©:",
        reply_markup=ReplyKeyboardMarkup(
            MAIN_MENU_KEYBOARD,
            one_time_keyboard=True,
            resize_keyboard=True
        )
    )

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Whenever user sends /start, show the custom or default welcome,
    then go to CHOOSING_OPTION.
    """
    user = update.effective_user
    user_id = user.id

    if user_id not in known_users:
        known_users.add(user_id)
        save_users(known_users)

    if user_id in muted_users:
        await update.message.reply_text("âš ï¸ Ù„Ù‚Ø¯ ØªÙ… ÙƒØªÙ…Ùƒ Ù…Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª.")
        return ConversationHandler.END

    logger.info(f"User {user.username or user_id} used /start")

    if user_id in override_welcome_messages:
        welcome_text = override_welcome_messages[user_id]
    elif user_id == SPECIAL_USER_ID:
        welcome_text = "Ø§Ù‡Ù„Ø§ Ø²Ù‡Ø±Ø§Ø¡ ÙÙŠ Ø§Ù„Ø¨ÙˆØª Ù…Ø§Ù„ØªÙŠ ğŸŒ¹\nØ§ØªÙ…Ù†Ù‰ ØªØ³ØªÙØ§Ø¯ÙŠÙ† Ù…Ù†Ù‡ ^^"
    else:
        welcome_text = (
            "Ø§Ù„Ø³Ù„Ø§Ù… Ø¹Ù„ÙŠÙƒÙ… \nØ§Ù„Ø¨ÙˆØª ØªÙ… ØªØ·ÙˆÙŠØ±Ø© Ø¨ÙˆØ§Ø³Ø·Ø© @iwanna2die Ø­ØªÙ‰ ÙŠØ³Ø§Ø¹Ø¯ Ø§Ù„Ø·Ù„Ø§Ø¨ ^^\n\n"
            "Ø§Ù‡Ù„Ø§ ÙˆØ³Ù‡Ù„Ø§!"
        )

    await update.message.reply_text(welcome_text)
    await asyncio.sleep(0.3)

    await show_main_menu(update, context)
    return CHOOSING_OPTION

async def choice_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    text = (update.message.text or "").strip()

    if text == 'Ø­Ø³Ø§Ø¨ ØºÙŠØ§Ø¨ Ø§Ù„Ù†Ø¸Ø±ÙŠ':
        await update.message.reply_text(
            "Ø§ÙƒØªØ¨ Ø±Ù‚Ù… Ø§Ù„ÙƒØ±Ø¯Øª Ù„Ù…Ø§Ø¯Ø© Ø§Ù„Ù†Ø¸Ø±ÙŠ (Ù…Ø«Ø§Ù„: 3.0).\n\n"
            "Ø£Ùˆ Ø§Ø®ØªØ± 'Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©' ÙÙŠ Ø§Ù„Ø£Ø³ÙÙ„:",
            reply_markup=ReplyKeyboardMarkup(
                [['Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©']],
                one_time_keyboard=True,
                resize_keyboard=True
            )
        )
        return GET_THEORETICAL_CREDIT

    elif text == 'Ø­Ø³Ø§Ø¨ ØºÙŠØ§Ø¨ Ø§Ù„Ø¹Ù…Ù„ÙŠ':
        await update.message.reply_text(
            "Ø§ÙƒØªØ¨ Ø±Ù‚Ù… Ø§Ù„ÙƒØ±Ø¯Øª Ù„Ù…Ø§Ø¯Ø© Ø§Ù„Ø¹Ù…Ù„ÙŠ (Ù…Ø«Ø§Ù„: 1.5).\n\n"
            "Ø£Ùˆ Ø§Ø®ØªØ± 'Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©' ÙÙŠ Ø§Ù„Ø£Ø³ÙÙ„:",
            reply_markup=ReplyKeyboardMarkup(
                [['Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©']],
                one_time_keyboard=True,
                resize_keyboard=True
            )
        )
        return GET_PRACTICAL_CREDIT

    elif text == 'Ø§Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø© Ù„ØµØ§Ø­Ø¨ Ø§Ù„Ø¨ÙˆØª':
        await update.message.reply_text(
            "ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„ØªÙƒ Ø§Ù„Ø¢Ù†ØŒ Ø£Ùˆ Ø§Ø®ØªØ± Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©:",
            reply_markup=ReplyKeyboardMarkup(
                [['Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©']],
                one_time_keyboard=True,
                resize_keyboard=True
            )
        )
        return SEND_MESSAGE

    elif text == 'Ø­Ø³Ø§Ø¨ Ø¯Ø±Ø¬ØªÙƒ Ø¨Ù„Ø¨Ù„ÙˆÙƒ':
        await update.message.reply_text(
            "Ø´ÙƒØ¯ Ø§Ù„Ù…Ø§Ø¯Ø© Ø¹Ù„ÙŠÙ‡Ø§ Ø¨Ù„Ø¨Ù„ÙˆÙƒØŸ (Ø§ÙƒØªØ¨ Ø±Ù‚Ù… ÙÙ‚Ø·)",
            reply_markup=ReplyKeyboardMarkup(
                [['Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©']],
                one_time_keyboard=True,
                resize_keyboard=True
            )
        )
        return BLOK_MATERIA

    else:
        await update.message.reply_text("Ø®ÙŠØ§Ø± ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ!")
        await show_main_menu(update, context)
        return CHOOSING_OPTION

async def theoretical_credit(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    text = (update.message.text or "").strip()
    if text == 'Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©':
        await show_main_menu(update, context)
        return CHOOSING_OPTION

    try:
        credit = float(text)
        result = credit * 8 * 0.2352941176
        await update.message.reply_text(f"ØºÙŠØ§Ø¨Ùƒ Ù„Ù„Ù†Ø¸Ø±ÙŠ Ù‡Ùˆ: {result}")
    except ValueError:
        await update.message.reply_text(
            "Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… ÙÙ‚Ø·.\nÙ…Ø«Ø§Ù„: 3.0 Ø£Ùˆ 2.5\n"
            "Ø£Ùˆ Ø§Ø®ØªØ± Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©."
        )
        return GET_THEORETICAL_CREDIT

    await show_main_menu(update, context)
    return CHOOSING_OPTION

async def practical_credit(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    text = (update.message.text or "").strip()
    if text == 'Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©':
        await show_main_menu(update, context)
        return CHOOSING_OPTION

    try:
        credit = float(text)
        result = credit * 8 * 0.1176470588
        await update.message.reply_text(f"ØºÙŠØ§Ø¨Ùƒ Ù„Ù„Ø¹Ù…Ù„ÙŠ Ù‡Ùˆ: {result}")
    except ValueError:
        await update.message.reply_text(
            "Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… ÙÙ‚Ø·.\nÙ…Ø«Ø§Ù„: 1 Ø£Ùˆ 1.5\n"
            "Ø£Ùˆ Ø§Ø®ØªØ± Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©."
        )
        return GET_PRACTICAL_CREDIT

    await show_main_menu(update, context)
    return CHOOSING_OPTION

# Ø¨Ù„Ø¨Ù„ÙˆÙƒ
async def blok_materia(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    text = (update.message.text or "").strip()
    if text == 'Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©':
        await show_main_menu(update, context)
        return CHOOSING_OPTION

    try:
        context.user_data['blok_materia'] = float(text)
        await update.message.reply_text(
            "Ø´ÙƒØ¯ Ø§Ù„Ø¯Ø±Ø¬Ø© Ø§Ù„ÙƒÙ„ÙŠØ© Ù„Ù‡Ø°ÙŠ Ø§Ù„Ù…Ø§Ø¯Ø©ØŸ (Ø§ÙƒØªØ¨ Ø±Ù‚Ù… ÙÙ‚Ø·)",
            reply_markup=ReplyKeyboardMarkup(
                [['Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©']],
                one_time_keyboard=True,
                resize_keyboard=True
            )
        )
        return BLOK_TOTAL
    except ValueError:
        await update.message.reply_text("Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… ØµØ§Ù„Ø­.")
        return BLOK_MATERIA

async def blok_total(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    text = (update.message.text or "").strip()
    if text == 'Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©':
        await show_main_menu(update, context)
        return CHOOSING_OPTION

    try:
        context.user_data['blok_total'] = float(text)
        await update.message.reply_text(
            "Ø´ÙƒØ¯ Ø®Ø°ÙŠØªØŸ (Ø§ÙƒØªØ¨ Ø±Ù‚Ù… ÙÙ‚Ø·)",
            reply_markup=ReplyKeyboardMarkup(
                [['Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©']],
                one_time_keyboard=True,
                resize_keyboard=True
            )
        )
        return BLOK_TAKEN
    except ValueError:
        await update.message.reply_text("Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… ØµØ§Ù„Ø­.")
        return BLOK_TOTAL

async def blok_taken(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    text = (update.message.text or "").strip()
    if text == 'Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©':
        await show_main_menu(update, context)
        return CHOOSING_OPTION

    try:
        taken = float(text)
        materia_val = context.user_data.get('blok_materia', 0)
        total_val = context.user_data.get('blok_total', 1)
        result = (materia_val * taken) / total_val
        await update.message.reply_text(f"Ø¯Ø±Ø¬ØªÙƒ Ø¨Ù„Ø¨Ù„ÙˆÙƒ Ù‡ÙŠ: {result}")
    except ValueError:
        await update.message.reply_text("Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… ØµØ§Ù„Ø­.")
        return BLOK_TAKEN

    await show_main_menu(update, context)
    return CHOOSING_OPTION

# Ø§Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø© Ù„ØµØ§Ø­Ø¨ Ø§Ù„Ø¨ÙˆØª
async def send_message_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    text = (update.message.text or "").strip()
    if text == 'Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©':
        await show_main_menu(update, context)
        return CHOOSING_OPTION

    user = update.effective_user
    user_id = user.id
    username = user.username or f"ID {user_id}"

    if text:
        try:
            formatted = f"Ø±Ø³Ø§Ù„Ø© Ù…Ù† @{username} (ID: {user_id}):\n\n{text}"
            await context.bot.send_message(chat_id=AUTHORIZED_USER_ID, text=formatted)
            await update.message.reply_text("ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø¨Ù†Ø¬Ø§Ø­.")
        except Exception as e:
            logger.error(f"Failed to forward message: {e}")
            await update.message.reply_text("Ø­ØµÙ„ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø©. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.")
    else:
        await update.message.reply_text("Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù†Øµ Ù„Ù„Ø±Ø³Ø§Ù„Ø©.")

    await show_main_menu(update, context)
    return CHOOSING_OPTION

# /user_id -> message to SPECIAL_USER_ID
async def user_id_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if update.effective_user.id != AUTHORIZED_USER_ID:
        await update.message.reply_text("You are not authorized to use this command.")
        return ConversationHandler.END

    await update.message.reply_text(
        "Send your message for the SPECIAL_USER_ID:",
        reply_markup=ReplyKeyboardRemove()
    )
    return USER_ID_WAITING_FOR_MESSAGE

async def user_message_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    text = (update.message.text or "").strip()
    user = update.effective_user

    if text:
        try:
            msg = f"Message from {user.username or user.id} (ID: {user.id}):\n{text}"
            await context.bot.send_message(chat_id=SPECIAL_USER_ID, text=msg)
            await update.message.reply_text("ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„ØªÙƒ Ø¨Ù†Ø¬Ø§Ø­!")
        except Exception as e:
            logger.error(f"Failed sending message to SPECIAL_USER_ID: {e}")
            await update.message.reply_text("Ø­ØµÙ„ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø©.")
    else:
        await update.message.reply_text("Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù†Øµ ÙÙŠ Ø§Ù„Ø±Ø³Ø§Ù„Ø©!")
    return ConversationHandler.END

# /user_m <userid> -> send a custom message to any user
async def user_m_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if update.effective_user.id != AUTHORIZED_USER_ID:
        await update.message.reply_text("You are not authorized to use this command.")
        return ConversationHandler.END

    if len(context.args) != 1:
        await update.message.reply_text("Usage: /user_m <userid>")
        return ConversationHandler.END

    try:
        target_id = int(context.args[0])
    except ValueError:
        await update.message.reply_text("Invalid user ID. Must be an integer.")
        return ConversationHandler.END

    context.user_data['target_user_id'] = target_id
    await update.message.reply_text(
        f"Ø³ØªÙ‚ÙˆÙ… Ø¨Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ {target_id}. Ø§ÙƒØªØ¨ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø¢Ù†:",
        reply_markup=ReplyKeyboardRemove()
    )
    return USER_M_WAITING_FOR_MESSAGE

async def user_m_message_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    text = (update.message.text or "").strip()
    if not text:
        await update.message.reply_text("Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù†Øµ Ù„Ù„Ø±Ø³Ø§Ù„Ø©!")
        return ConversationHandler.END

    target_id = context.user_data.get('target_user_id')
    if not target_id:
        await update.message.reply_text("Ù„Ù… Ø£Ø¬Ø¯ user_id! Ø£Ø¹Ø¯ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.")
        return ConversationHandler.END

    try:
        await context.bot.send_message(chat_id=target_id, text=text)
        await update.message.reply_text(f"ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„ØªÙƒ Ø¥Ù„Ù‰ {target_id} Ø¨Ù†Ø¬Ø§Ø­!")
    except Exception as e:
        logger.error(f"Failed sending message to {target_id}: {e}")
        await update.message.reply_text("Ø­ØµÙ„ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø©.")
    return ConversationHandler.END

# /hey <userid> -> set a custom welcome
async def hey_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if update.effective_user.id != AUTHORIZED_USER_ID:
        await update.message.reply_text("You are not authorized to use this command.")
        return ConversationHandler.END

    if len(context.args) != 1:
        await update.message.reply_text("Usage: /hey <userid>")
        return ConversationHandler.END

    try:
        target_id = int(context.args[0])
    except ValueError:
        await update.message.reply_text("Invalid user ID. Must be an integer.")
        return ConversationHandler.END

    context.user_data['hey_target_id'] = target_id
    await update.message.reply_text(
        f"Ø³ØªÙ‚ÙˆÙ… Ø¨ØªØºÙŠÙŠØ± Ø§Ù„ØªØ±Ø­ÙŠØ¨ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… {target_id}. Ø§ÙƒØªØ¨ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø¢Ù†:",
        reply_markup=ReplyKeyboardRemove()
    )
    return HEY_WAITING_FOR_MESSAGE

async def hey_message_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    new_msg = (update.message.text or "").strip()
    if not new_msg:
        await update.message.reply_text("Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù†Øµ Ø§Ù„Ø±Ø³Ø§Ù„Ø©! Ø£Ø¹Ø¯ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©.")
        return ConversationHandler.END

    target_id = context.user_data.get('hey_target_id')
    if not target_id:
        await update.message.reply_text("Ù„Ù… Ø£Ø¬Ø¯ user_id! Ø£Ø¹Ø¯ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.")
        return ConversationHandler.END

    override_welcome_messages[target_id] = new_msg
    save_override_welcomes(override_welcome_messages)

    await update.message.reply_text(
        f"ØªÙ… ØªØºÙŠÙŠØ± Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªØ±Ø­ÙŠØ¨ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… {target_id} Ø¨Ù†Ø¬Ø§Ø­!\n"
        f"Ø§Ù„ØªØ±Ø­ÙŠØ¨ Ø§Ù„Ø¬Ø¯ÙŠØ¯: {new_msg}"
    )
    return ConversationHandler.END

# /hey_r <userid> -> remove a custom welcome
async def hey_remove_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if update.effective_user.id != AUTHORIZED_USER_ID:
        await update.message.reply_text("You are not authorized to use this command.")
        return

    if len(context.args) != 1:
        await update.message.reply_text("Usage: /hey_r <userid>")
        return

    try:
        target_id = int(context.args[0])
    except ValueError:
        await update.message.reply_text("Invalid user ID. Must be an integer.")
        return

    if target_id in override_welcome_messages:
        del override_welcome_messages[target_id]
        save_override_welcomes(override_welcome_messages)
        await update.message.reply_text(
            f"ØªÙ… Ø­Ø°Ù Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªØ±Ø­ÙŠØ¨ Ø§Ù„Ù…Ø®ØµØµØ© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… {target_id}.\n"
            "Ø§Ù„Ø¢Ù† Ø³ÙŠØ­ØµÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ© Ø¹Ù†Ø¯ Ø§Ø³ØªØ®Ø¯Ø§Ù… /start."
        )
    else:
        await update.message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù„ÙŠØ³ Ù„Ø¯ÙŠÙ‡ Ø±Ø³Ø§Ù„Ø© ØªØ±Ø­ÙŠØ¨ Ù…Ø®ØµØµØ©.")

# /new broadcast flow
async def broadcast_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if update.effective_user.id != AUTHORIZED_USER_ID:
        await update.message.reply_text("You are not authorized to use this command.")
        return ConversationHandler.END

    await update.message.reply_text(
        "Ù…Ø§ Ù‡ÙŠ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯ Ø¥Ø±Ø³Ø§Ù„Ù‡Ø§ Ù„Ù„Ø¬Ù…ÙŠØ¹ØŸ\n\n(Ø§ÙƒØªØ¨ /cancel Ù„Ù„Ø¥Ù„ØºØ§Ø¡)",
        reply_markup=ReplyKeyboardRemove()
    )
    return BROADCAST_ASK_MESSAGE

async def broadcast_ask_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data['broadcast_msg'] = update.message.text
    confirm_keyboard = [["Ù†Ø¹Ù…ØŒ Ø¥Ø±Ø³Ø§Ù„", "Ø¥Ù„ØºØ§Ø¡"]]
    await update.message.reply_text(
        f"Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ø±Ø³Ø§Ù„ Ù‡Ø°Ù‡ Ø§Ù„Ø±Ø³Ø§Ù„Ø©ØŸ\n\nÂ«{update.message.text}Â»",
        reply_markup=ReplyKeyboardMarkup(confirm_keyboard, resize_keyboard=True, one_time_keyboard=True)
    )
    return BROADCAST_CONFIRMATION

async def broadcast_confirmation(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    text = (update.message.text or "").strip()
    if text == "Ù†Ø¹Ù…ØŒ Ø¥Ø±Ø³Ø§Ù„":
        broadcast_msg = context.user_data.get('broadcast_msg', "")
        if not broadcast_msg:
            await update.message.reply_text("Ù„Ø§ ØªÙˆØ¬Ø¯ Ø±Ø³Ø§Ù„Ø© Ù„Ù„Ø¥Ø±Ø³Ø§Ù„!")
            return ConversationHandler.END

        sent_count = 0
        for uid in known_users:
            try:
                await context.bot.send_message(chat_id=uid, text=broadcast_msg)
                sent_count += 1
            except Exception as e:
                logger.error(f"Could not send to user {uid}: {e}")

        await update.message.reply_text(f"ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ {sent_count} Ù…Ø³ØªØ®Ø¯Ù…/Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†.")
    else:
        await update.message.reply_text("ØªÙ… Ø§Ù„Ø¥Ù„ØºØ§Ø¡.")
    return ConversationHandler.END

# Mute/Unmute/Mutelist
async def muteid_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if update.effective_user.id != AUTHORIZED_USER_ID:
        await update.message.reply_text("You are not authorized.")
        return

    if len(context.args) != 1:
        await update.message.reply_text("Usage: /muteid <userid>")
        return

    try:
        target_id = int(context.args[0])
    except ValueError:
        await update.message.reply_text("Provide a valid user ID.")
        return

    if target_id in muted_users:
        await update.message.reply_text("User is already muted.")
    else:
        muted_users.add(target_id)
        save_muted_users(muted_users)
        await update.message.reply_text(f"User {target_id} has been muted.")

async def unmuteid_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if update.effective_user.id != AUTHORIZED_USER_ID:
        await update.message.reply_text("You are not authorized.")
        return

    if len(context.args) != 1:
        await update.message.reply_text("Usage: /unmuteid <userid>")
        return

    try:
        target_id = int(context.args[0])
    except ValueError:
        await update.message.reply_text("Provide a valid user ID.")
        return

    if target_id in muted_users:
        muted_users.remove(target_id)
        save_muted_users(muted_users)
        await update.message.reply_text(f"User {target_id} has been unmuted.")
    else:
        await update.message.reply_text("User is not muted.")

async def mutelist_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if update.effective_user.id != AUTHORIZED_USER_ID:
        await update.message.reply_text("You are not authorized.")
        return

    if muted_users:
        text = "\n".join(str(u) for u in muted_users)
        await update.message.reply_text("Muted users:\n" + text)
    else:
        await update.message.reply_text("No muted users.")

# /help
async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id
    if user_id == AUTHORIZED_USER_ID:
        admin_help_text = (
            "ğŸš€ Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù…Ø´Ø±Ù:\n\n"
            "/help - Ø¥Ø¸Ù‡Ø§Ø± Ù‡Ø°Ù‡ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©.\n"
            "/start - Ø¨Ø¯Ø¡ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© Ø£Ùˆ Ø¹Ø±Ø¶ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©.\n"
            "/muteid <userid> - ÙƒØªÙ… Ù…Ø³ØªØ®Ø¯Ù….\n"
            "/unmuteid <userid> - Ø¥Ù„ØºØ§Ø¡ ÙƒØªÙ… Ù…Ø³ØªØ®Ø¯Ù….\n"
            "/mutelist - Ø¹Ø±Ø¶ Ø§Ù„Ù…ÙƒØªÙˆÙ…ÙŠÙ†.\n"
            "/user_id - Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ SPECIAL_USER_ID.\n"
            "/user_m <userid> - Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ user_id.\n"
            "/hey <userid> - ØªØ¹ÙŠÙŠÙ† Ø±Ø³Ø§Ù„Ø© ØªØ±Ø­ÙŠØ¨ Ù…Ø®ØµØµØ©.\n"
            "/hey_r <userid> - Ø­Ø°Ù Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªØ±Ø­ÙŠØ¨ Ø§Ù„Ù…Ø®ØµØµØ©.\n"
            "/new - Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¬Ù…Ø§Ø¹ÙŠØ© Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†.\n"
            "/cancel - Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø­Ø§Ù„ÙŠØ©.\n"
        )
        await update.message.reply_text(admin_help_text)
    else:
        user_help_text = (
            "Ù…Ø±Ø­Ø¨Ø§Ù‹! Ø£Ù†Ø§ Ø¨ÙˆØª Ù„Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©.\n"
            "Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù…ØªØ§Ø­Ø©:\n"
            "/start - Ø¨Ø¯Ø¡ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© Ø£Ùˆ Ø¹Ø±Ø¶ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©.\n"
            "/help - Ø¹Ø±Ø¶ Ù‡Ø°Ù‡ Ø§Ù„Ø±Ø³Ø§Ù„Ø©.\n"
        )
        await update.message.reply_text(user_help_text)

# Mute filter
class MuteFilter(MessageFilter):
    def filter(self, message):
        return message.from_user and (message.from_user.id in muted_users)

async def handle_muted(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if not user:
        return
    user_id = user.id
    username = user.username or f"ID {user_id}"
    first_name = user.first_name or ""
    last_name = user.last_name or ""
    full_name = (first_name + " " + last_name).strip()

    # Notify the authorized user
    note = (
        "âš ï¸ Muted user tried to interact:\n\n"
        f"â€¢ ID: {user_id}\n"
        f"â€¢ Username: @{username}\n"
        f"â€¢ Full Name: {full_name if full_name else 'Not provided'}"
    )
    try:
        await context.bot.send_message(chat_id=AUTHORIZED_USER_ID, text=note)
    except Exception as e:
        logger.error(f"Failed to notify admin of muted user attempt: {e}")

    await update.message.reply_text("âš ï¸ Ø£Ù†Øª Ù…ÙƒØªÙˆÙ… ÙˆÙ„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙˆØª.")

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    await update.message.reply_text("ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.")
    return ConversationHandler.END

async def default_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    If no states or commands catch the message,
    we politely tell the user we didn't understand â€“ unless it's /start,
    which is now handled by the fallback in the conversation.
    """
    user_id = update.effective_user.id if update.effective_user else None
    if user_id and (user_id in muted_users):
        await update.message.reply_text("âš ï¸ Ø£Ù†Øª Ù…ÙƒØªÙˆÙ….")
        return

    await update.message.reply_text(
        "Ù„Ù… Ø£ÙÙ‡Ù… Ø±Ø³Ø§Ù„ØªÙƒØŒ Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø²Ø±Ø§Ø± ÙÙŠ Ø§Ù„Ø£Ø³ÙÙ„ Ø£Ùˆ Ø§ÙƒØªØ¨ /start Ù„Ù„Ø¨Ø¯Ø¡ Ù…Ù† Ø¬Ø¯ÙŠØ¯."
    )

async def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
    logger.error("Exception while handling an update:", exc_info=context.error)
    if isinstance(update, Update) and update.effective_message:
        await update.effective_message.reply_text("Ø¹Ø°Ø±Ø§Ù‹ Ø­ØµÙ„ Ø®Ø·Ø£. Ø­Ø§ÙˆÙ„ Ù…Ø¬Ø¯Ø¯Ø§Ù‹.")

def main():
    BOT_TOKEN = os.environ.get("BOT_TOKEN")
    if not BOT_TOKEN:
        logger.error("BOT_TOKEN is not set.")
        return

    # Remove webhook if any, so we can do polling
    try:
        bot = Bot(token=BOT_TOKEN)
        bot.delete_webhook(drop_pending_updates=True)
        logger.info("Webhook deleted.")
    except Exception as e:
        logger.warning(f"No webhook to delete or error: {e}")

    app = ApplicationBuilder().token(BOT_TOKEN).build()

    # Highest priority: Mute filter
    mute_filter = MuteFilter()
    app.add_handler(MessageHandler(mute_filter, handle_muted), group=0)

    # Main conversation
    conv_handler = ConversationHandler(
        entry_points=[CommandHandler('start', start)],
        states={
            CHOOSING_OPTION: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, choice_handler),
            ],
            GET_THEORETICAL_CREDIT: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, theoretical_credit),
            ],
            GET_PRACTICAL_CREDIT: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, practical_credit),
            ],
            SEND_MESSAGE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, send_message_handler),
            ],
            BLOK_MATERIA: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, blok_materia),
            ],
            BLOK_TOTAL: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, blok_total),
            ],
            BLOK_TAKEN: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, blok_taken),
            ],
        },
        # IMPORTANT: add 'start' in fallbacks, allow_reentry => user can re-run /start anytime
        fallbacks=[
            CommandHandler('cancel', cancel),
            CommandHandler('start', start),
        ],
        allow_reentry=True
    )

    # /user_id conversation
    user_id_conv = ConversationHandler(
        entry_points=[CommandHandler('user_id', user_id_command)],
        states={
            USER_ID_WAITING_FOR_MESSAGE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, user_message_handler),
            ],
        },
        fallbacks=[CommandHandler('cancel', cancel)],
        allow_reentry=False
    )

    # /user_m conversation
    user_m_conv = ConversationHandler(
        entry_points=[CommandHandler('user_m', user_m_command)],
        states={
            USER_M_WAITING_FOR_MESSAGE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, user_m_message_handler)
            ],
        },
        fallbacks=[CommandHandler('cancel', cancel)],
        allow_reentry=False
    )

    # /hey conversation
    hey_conv = ConversationHandler(
        entry_points=[CommandHandler('hey', hey_command)],
        states={
            HEY_WAITING_FOR_MESSAGE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, hey_message_handler)
            ],
        },
        fallbacks=[CommandHandler('cancel', cancel)],
        allow_reentry=False
    )

    # /new broadcast conversation
    broadcast_conv = ConversationHandler(
        entry_points=[CommandHandler('new', broadcast_start)],
        states={
            BROADCAST_ASK_MESSAGE: [
                MessageHandler(filters.ALL & ~filters.Regex('^/cancel$'), broadcast_ask_message)
            ],
            BROADCAST_CONFIRMATION: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, broadcast_confirmation)
            ],
        },
        fallbacks=[CommandHandler('cancel', cancel)],
        allow_reentry=False
    )

    # Register conversation handlers
    app.add_handler(conv_handler)
    app.add_handler(user_id_conv)
    app.add_handler(user_m_conv)
    app.add_handler(hey_conv)
    app.add_handler(broadcast_conv)

    # Other commands
    app.add_handler(CommandHandler('hey_r', hey_remove_command))
    app.add_handler(CommandHandler('muteid', muteid_command))
    app.add_handler(CommandHandler('unmuteid', unmuteid_command))
    app.add_handler(CommandHandler('mutelist', mutelist_command))
    app.add_handler(CommandHandler('help', help_command))

    # Fallback for everything else
    app.add_handler(MessageHandler(filters.ALL, default_handler))

    # Error handler
    app.add_error_handler(error_handler)

    logger.info("Running bot with polling...")
    app.run_polling(drop_pending_updates=True)

if __name__ == '__main__':
    main()
