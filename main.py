import logging
import os
from telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove
from telegram.ext import (
    ApplicationBuilder,
    CommandHandler,
    MessageHandler,
    filters,
    ContextTypes,
    ConversationHandler,
)

# Enable logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Define states for ConversationHandler
CHOOSING_OPTION, GET_THEORETICAL_CREDIT, GET_PRACTICAL_CREDIT = range(3)

# Special User ID
SPECIAL_USER_ID = 6733595501  # Ensure this is an integer

# Start command handler
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user = update.effective_user
    user_id = user.id

    # Log the user ID for debugging
    logger.info(f"User {user.username or 'No Username'} with ID {user_id} started the bot.")

    reply_keyboard = [['Ø­Ø³Ø§Ø¨ ØºÙŠØ§Ø¨ Ø§Ù„Ù†Ø¸Ø±ÙŠ', 'Ø­Ø³Ø§Ø¨ ØºÙŠØ§Ø¨ Ø§Ù„Ø¹Ù…Ù„ÙŠ']]

    if user_id == SPECIAL_USER_ID:
        # Personalized welcome message for the special user
        welcome_message = "Ø§Ù‡Ù„Ø§ Ø²Ù‡Ø±Ø§Ø¡ ÙÙŠ Ø§Ù„Ø¨ÙˆØª Ù…Ø§Ù„ØªÙŠ ðŸŒ¹\nØ§ØªÙ…Ù†Ù‰ ØªØ³ØªÙØ§Ø¯ÙŠÙ† Ù…Ù†Ù‡ ^^"
        logger.info(f"Sending personalized message to user ID {user_id}.")
    else:
        # Default welcome message for other users
        welcome_message = (
            "Ø§Ù„Ø³Ù„Ø§Ù… Ø¹Ù„ÙŠÙƒÙ… \nØ§Ù„Ø¨ÙˆØª ØªÙ… ØªØ·ÙˆÙŠØ±Ø© Ø¨ÙˆØ§Ø³Ø·Ø© @iwanna2die Ø­ØªÙ‰ ÙŠØ³Ø§Ø¹Ø¯ Ø§Ù„Ø·Ù„Ø§Ø¨ ^^"
        )
        logger.info(f"Sending default message to user ID {user_id}.")

    await update.message.reply_text(
        welcome_message,
        reply_markup=ReplyKeyboardMarkup(
            reply_keyboard, one_time_keyboard=True, resize_keyboard=True
        )
    )
    return CHOOSING_OPTION

# Handler for choosing option
async def choice_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    text = update.message.text

    if text == 'Ø­Ø³Ø§Ø¨ ØºÙŠØ§Ø¨ Ø§Ù„Ù†Ø¸Ø±ÙŠ':
        await update.message.reply_text(
            "Ø§Ø±Ø³Ù„ ÙƒØ±Ø¯Øª Ù…Ø§Ø¯Ø© Ø§Ù„Ù†Ø¸Ø±ÙŠ",
            reply_markup=ReplyKeyboardMarkup(
                [['Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©']], resize_keyboard=True, one_time_keyboard=True
            )
        )
        return GET_THEORETICAL_CREDIT

    elif text == 'Ø­Ø³Ø§Ø¨ ØºÙŠØ§Ø¨ Ø§Ù„Ø¹Ù…Ù„ÙŠ':
        await update.message.reply_text(
            "Ø§Ø±Ø³Ù„ Ø±ÙƒØ¯Øª Ø§Ù„Ø¹Ù…Ù„ÙŠ",
            reply_markup=ReplyKeyboardMarkup(
                [['Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©']], resize_keyboard=True, one_time_keyboard=True
            )
        )
        return GET_PRACTICAL_CREDIT

    else:
        await update.message.reply_text(
            "Ø§Ø®ØªÙŠØ§Ø± ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ø§Ø®ØªÙŠØ§Ø± Ù…Ù† Ø§Ù„Ø£Ø²Ø±Ø§Ø±.",
            reply_markup=ReplyKeyboardMarkup(
                [['Ø­Ø³Ø§Ø¨ ØºÙŠØ§Ø¨ Ø§Ù„Ù†Ø¸Ø±ÙŠ', 'Ø­Ø³Ø§Ø¨ ØºÙŠØ§Ø¨ Ø§Ù„Ø¹Ù…Ù„ÙŠ']], resize_keyboard=True
            )
        )
        return CHOOSING_OPTION

# Handler for theoretical credit input
async def theoretical_credit(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    text = update.message.text

    if text == 'Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©':
        return await start(update, context)

    try:
        credit = float(text)
        result = credit * 8 * 0.23
        await update.message.reply_text(f"{result}")
        return await start(update, context)
    except ValueError:
        await update.message.reply_text("Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… ØµØ­ÙŠØ­ Ø£Ùˆ Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©.")
        return GET_THEORETICAL_CREDIT

# Handler for practical credit input
async def practical_credit(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    text = update.message.text

    if text == 'Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©':
        return await start(update, context)

    try:
        credit = float(text)
        result = credit * 8 * 0.1176470588
        await update.message.reply_text(f"{result}")
        return await start(update, context)
    except ValueError:
        await update.message.reply_text("Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… ØµØ­ÙŠØ­ Ø£Ùˆ Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©.")
        return GET_PRACTICAL_CREDIT

# Fallback handler for /cancel command
async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    await update.message.reply_text(
        "ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©. Ù„Ù„Ø¨Ø¯Ø¡ Ù…Ù† Ø¬Ø¯ÙŠØ¯ØŒ Ø§Ø±Ø³Ù„ /start",
        reply_markup=ReplyKeyboardRemove()
    )
    return ConversationHandler.END

def main():
    # Retrieve the bot token from environment variables
    BOT_TOKEN = os.environ.get("BOT_TOKEN")
    
    if not BOT_TOKEN:
        logger.error("BOT_TOKEN environment variable not set.")
        exit(1)

    # Initialize the bot application
    application = ApplicationBuilder().token(BOT_TOKEN).build()

    # Define the ConversationHandler
    conv_handler = ConversationHandler(
        entry_points=[CommandHandler('start', start)],
        states={
            CHOOSING_OPTION: [
                MessageHandler(
                    filters.Regex('^(Ø­Ø³Ø§Ø¨ ØºÙŠØ§Ø¨ Ø§Ù„Ù†Ø¸Ø±ÙŠ|Ø­Ø³Ø§Ø¨ ØºÙŠØ§Ø¨ Ø§Ù„Ø¹Ù…Ù„ÙŠ)$'), choice_handler
                )
            ],
            GET_THEORETICAL_CREDIT: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, theoretical_credit)
            ],
            GET_PRACTICAL_CREDIT: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, practical_credit)
            ],
        },
        fallbacks=[CommandHandler('cancel', cancel)],
        allow_reentry=True
    )

    application.add_handler(conv_handler)

    # Start the bot
    application.run_polling()

if __name__ == '__main__':
    main()
 
